package com.tbohne.sqlite.processor.models;

import com.google.common.collect.ImmutableList;
import com.tbohne.sqlite.binders.RawBinder;
import com.tbohne.sqlite.processor.util.Output;
import com.tbohne.sqlite.processor.util.ProcessorHelpers;
import com.tbohne.sqlite.processor.util.SqlAnnotMethods;
import com.tbohne.sqlite.processor.util.StringHelpers;

import org.checkerframework.checker.nullness.qual.Nullable;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;
import java.util.function.Predicate;

import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;

/**
 * {@link MultiBinder}
 */
public class JavaBinderModel<ColumnType extends AbstractColumnModel> {
	public final String binderName;
	public final @Nullable String tableJavaName;
	public final String columnJavaName;
	public final boolean isRawBinder;
	public final DeclaredType binderMirror;
	public final ImmutableList<ColumnType> columns;
	public final TypeMirror toSqlJavaMirror;
	public final TypeMirror toSqlSqlMirror;
	public final TypeMirror fromSqlJavaMirror;
	public final String toSqlParameterName;
	public final boolean toSqlHasContentValues;
	public final boolean toSqlStatic;
	public final boolean fromSqlStatic;
	public final boolean bothStatic;
	public final boolean isAutoGeneratedPrimaryKey;

	private JavaBinderModel(
			String binderName,
			@Nullable String tableJavaName,
			String columnJavaName,
			boolean isRawBinder,
			DeclaredType binderMirror,
			ImmutableList<ColumnType> columns,
			TypeMirror toSqlJavaMirror,
			TypeMirror toSqlSqlMirror,
			TypeMirror fromSqlJavaMirror,
			String toSqlParameterName,
			boolean toSqlHasContentValues,
			boolean toSqlStatic,
			boolean fromSqlStatic,
			boolean bothStatic,
			boolean isAutoGeneratedPrimaryKey)
	{
		this.binderName = binderName;
		this.tableJavaName = tableJavaName;
		this.columnJavaName = columnJavaName;
		this.isRawBinder = isRawBinder;
		this.binderMirror = binderMirror;
		this.columns = columns;
		this.toSqlJavaMirror = toSqlJavaMirror;
		this.toSqlSqlMirror = toSqlSqlMirror;
		this.fromSqlJavaMirror = fromSqlJavaMirror;
		this.toSqlParameterName = toSqlParameterName;
		this.toSqlHasContentValues = toSqlHasContentValues;
		this.toSqlStatic = toSqlStatic;
		this.fromSqlStatic = fromSqlStatic;
		this.bothStatic = bothStatic;
		this.isAutoGeneratedPrimaryKey = isAutoGeneratedPrimaryKey;
	}

	// looks for `SqlType binder#toSql(JavaType)` or `void binder#toSql(JavaType, ContentValues)`
	protected static <ColumnType extends AbstractColumnModel> ProcessorHelpers.@Nullable MethodElementTypePair getToSqlMethod(
			ProcessingEnvironment environment,
			@Nullable Output messager,
			TypeElement tableElement,
			String binderName,
			TypeElement binderDefinitionWithoutGenerics,
			DeclaredType binderInstanceWithGenerics,
			List<ColumnType> columns)
	{
		boolean foundFromSql = false;
		for (int j = 0; j < columns.size(); j++) {
			if (columns.get(j) == null) {
				return null;
			}
		}
		if (columns.isEmpty()) {
			throw new IllegalStateException("finder toSql method of no sql column");
		}
		//figure out desired signature
		Predicate<TypeMirror> returnType;
		ArrayList<@Nullable Predicate<TypeMirror>> parameterList = new ArrayList<>(2);
		String returnTypeString;
		ArrayList<String> parameterListStrings = new ArrayList<>(2);
		if (columns.size() == 1) {
			returnType = type -> SqlAnnotMethods.matchesRawSqlType(type, columns.get(0).affinity);
			returnTypeString = SqlAnnotMethods.getRawSqlTypeAsString(columns.get(0).affinity, columns.get(0).isNonNull);
			parameterList.add(null);
			parameterListStrings.add("JavaType");
		} else {
			TypeMirror voidMirror = environment.getTypeUtils().getNoType(TypeKind.VOID);
			returnType = type -> environment.getTypeUtils().isSameType(type, voidMirror);
			returnTypeString = "void";
			parameterList.add(null);
			parameterListStrings.add("JavaType");
			parameterList.add((typeMirror -> typeMirror.toString().contains("ContentProvider")));
			parameterListStrings.add("ContentProvider");
		}
		//find the method
		List<ExecutableElement> foundToSqlMethodsList = new ArrayList<>();
		ProcessorHelpers.MethodElementTypePair foundToSql = ProcessorHelpers.findMethod(environment.getTypeUtils(),
																																										binderDefinitionWithoutGenerics,
																																										binderInstanceWithGenerics,
																																										"toSql",
																																										returnType,
																																										parameterList,
																																										foundToSqlMethodsList);

		//if no method found, then report similar methods
		if (messager != null && foundToSql == null) {
			messager.error(tableElement, ProcessorHelpers.methodNotFoundErrorText(binderName,
																																						binderInstanceWithGenerics,
																																						"toSql",
																																						returnTypeString,
																																						parameterListStrings,
																																						foundToSqlMethodsList));
		}
		return foundToSql;
	}

	// looks for `SqlType binder#toSql(JavaType)` or `void binder#toSql(JavaType, ContentValues)`
	protected static <ColumnType extends AbstractColumnModel> ProcessorHelpers.@Nullable MethodElementTypePair getFromSqlMethod(
			ProcessingEnvironment environment,
			@Nullable Output messager,
			TypeElement tableElement,
			String binderName,
			TypeElement binderDefinitionWithoutGenerics,
			DeclaredType binderInstanceWithGenerics,
			List<ColumnType> columns)
	{
		boolean foundFromSql = false;
		for (int j = 0; j < columns.size(); j++) {
			if (columns.get(j) == null) {
				return null;
			}
		}
		if (columns.isEmpty()) {
			throw new IllegalStateException("finder fromSql method of no sql column");
		}
		//figure out desired signature
		Predicate<TypeMirror> returnType = type -> true;
		String returnTypeString = "JavaType";
		ArrayList<@Nullable Predicate<TypeMirror>> parameterList = new ArrayList<>(columns.size());
		ArrayList<String> parameterListStrings = new ArrayList<>(columns.size());
		for (int i = 0; i < columns.size(); i++) {
			TypeMirror sqlParameterType = columns.get(i).sqlBinders.get(0).rawSqlParameterType;
			parameterList.add(parameterMirror -> environment.getTypeUtils().isSameType(parameterMirror, sqlParameterType));
			parameterListStrings.add(sqlParameterType.toString());
		}
		//find the method
		List<ExecutableElement> foundToSqlMethodsList = new ArrayList<>();
		ProcessorHelpers.MethodElementTypePair foundToSql = ProcessorHelpers.findMethod(environment.getTypeUtils(),
																																										binderDefinitionWithoutGenerics,
																																										binderInstanceWithGenerics,
																																										"fromSql",
																																										returnType,
																																										parameterList,
																																										foundToSqlMethodsList);

		//if no method found, then report similar methods
		if (messager != null && foundToSql == null) {
			messager.error(tableElement, ProcessorHelpers.methodNotFoundErrorText(binderName,
																																						binderInstanceWithGenerics,
																																						"fromSql",
																																						returnTypeString,
																																						parameterListStrings,
																																						foundToSqlMethodsList));
		}
		return foundToSql;
	}

	public static <ColumnType extends AbstractColumnModel> ImmutableList<JavaBinderModel<ColumnType>> buildJavaBinderList(
			ProcessingEnvironment environment,
			@Nullable Output messager,
			TypeElement tableElement,
			ImmutableList<ColumnType> columnList)
	{
		HashMap<String, Builder<ColumnType>> builderMap = new HashMap<>();
		List<JavaBinderModel.Builder<ColumnType>> builderList = new ArrayList<>();
		for (int i = 0; i < columnList.size(); i++) {
			ColumnType column = columnList.get(i);
			for (int j = 0; j < column.sqlBinders.size(); j++) {
				SqlBinderModel sqlBinder = column.sqlBinders.get(j);
				String qualifiedJavaName = sqlBinder.tableJavaName + "." + sqlBinder.javaName;
				JavaBinderModel.Builder<ColumnType> javaBinder = builderMap.get(qualifiedJavaName);
				if (javaBinder == null) {
					javaBinder = new JavaBinderModel.Builder<>(column, sqlBinder);
					builderMap.put(qualifiedJavaName, javaBinder);
					builderList.add(javaBinder);
				} else {
					javaBinder.merge(environment, messager, tableElement, column, sqlBinder);
				}
			}
		}
		ImmutableList.Builder<JavaBinderModel<ColumnType>> result = ImmutableList.builder();
		for (int i = 0; i < builderList.size(); i++) {
			result.add(builderList.get(i).build(environment, messager, tableElement));
		}
		return result.build();
	}

	public static class Builder<ColumnType extends AbstractColumnModel> {
		public final @Nullable String tableJavaName;
		public final String javaName;
		public final DeclaredType binderMirror;
		public final boolean isAutoGeneratedPrimaryKey;
		private final List<ColumnType> columns;

		public Builder(ColumnType column, SqlBinderModel binder) {
			this.tableJavaName = column.tableJavaName;
			this.javaName = binder.javaName;
			this.binderMirror = binder.binderMirror;
			this.columns = new ArrayList<>(binder.index + 1);
			for (int i = 0; i < binder.index; i++) {
				this.columns.add(null);
			}
			this.columns.add(column);
			this.isAutoGeneratedPrimaryKey = column.isAutoGeneratedPrimaryKey;
		}

		public void merge(
				ProcessingEnvironment environment,
				@Nullable Output messager,
				TypeElement tableElement,
				ColumnType column,
				SqlBinderModel binder)
		{
			if (!binder.isAutoGeneratedPrimaryKey) {
				throw new IllegalStateException("merging implicit primary key columns");
			}
			if (!Objects.equals(binder.tableJavaName, tableJavaName)) {
				throw new IllegalStateException("merging binders from different tables?");
			}
			if (!binder.javaName.equals(javaName)) {
				throw new IllegalStateException("merging different binders");
			}
			if (messager != null && !environment.getTypeUtils().isSameType(binderMirror, binder.binderMirror)) {
				messager.error(tableElement,
											 "Column %s multibinder %s has binder %s instead of %s",
											 column.sqlName,
											 javaName,
											 binder.binderMirror,
											 binderMirror);
			}
			while (columns.size() <= binder.index) {
				columns.add(null);
			}
			ColumnType oldColumn = columns.get(binder.index);
			if (messager != null && oldColumn != null) {
				messager.error(tableElement,
											 "Column %s multibinder %s has parameter %s but so did column %s",
											 column.sqlName,
											 javaName,
											 binder.index,
											 oldColumn.sqlName);
			}
			columns.set(binder.index, column);
		}

		public JavaBinderModel<ColumnType> build(
				ProcessingEnvironment environment, @Nullable Output messager, TypeElement tableElement)
		{
			for (int i = columns.size() - 1; i >= 0; i--) {
				ColumnType column = columns.get(i);
				if (messager != null && column == null) {
					messager.error(tableElement, "multibinder %s is missing parameter index=%d", javaName, i);
				}
			}
			//TODO NULLABLE
			TypeElement rawBinderElement = environment.getElementUtils().getTypeElement(RawBinder.class.getName());
			DeclaredType rawBinderMirror = (DeclaredType) rawBinderElement.asType();
			TypeElement binderElement = (TypeElement) binderMirror.asElement();
			String binderName = StringHelpers.sqlToJava(binderElement.getSimpleName().toString());
			boolean isRawBinder = environment.getTypeUtils().isSameType(binderMirror, rawBinderMirror);
			ProcessorHelpers.MethodElementTypePair
					toSqlMethod =
					getToSqlMethod(environment, messager, tableElement, javaName, binderElement, binderMirror, columns);
			ProcessorHelpers.MethodElementTypePair
					fromSqlMethod =
					getFromSqlMethod(environment, messager, tableElement, javaName, binderElement, binderMirror, columns);
			TypeMirror
					toSqlJavaMirror =
					toSqlMethod == null
					? environment.getElementUtils().getTypeElement("java.lang.Object").asType()
					: toSqlMethod.methodCallWithGenerics.getParameterTypes().get(0);
			TypeMirror
					toSqlSqlMirror =
					toSqlMethod == null
					? environment.getElementUtils().getTypeElement("java.lang.Object").asType()
					: toSqlMethod.methodCallWithGenerics.getReturnType();
			TypeMirror
					fromSqlJavaMirror =
					fromSqlMethod == null
					? environment.getElementUtils().getTypeElement("java.lang.Object").asType()
					: fromSqlMethod.methodCallWithGenerics.getReturnType();
			String
					toSqlParameterName =
					toSqlMethod == null
					? "value"
					: toSqlMethod.methodBodyNoGenerics.getParameters().get(0).getSimpleName().toString();

			boolean
					toSqlHasContentValues =
					toSqlMethod != null && toSqlMethod.methodBodyNoGenerics.getParameters().size() == 2;
			boolean
					toSqlStatic =
					toSqlMethod != null && toSqlMethod.methodBodyNoGenerics.getModifiers().contains(Modifier.STATIC);
			boolean
					fromSqlStatic =
					fromSqlMethod != null && fromSqlMethod.methodBodyNoGenerics.getModifiers().contains(Modifier.STATIC);
			boolean bothStatic = toSqlStatic && fromSqlStatic;
			return new JavaBinderModel<>(binderName,
																	 tableJavaName,
																	 javaName,
																	 isRawBinder,
																	 binderMirror,
																	 ImmutableList.copyOf(columns),
																	 toSqlJavaMirror,
																	 toSqlSqlMirror,
																	 fromSqlJavaMirror,
																	 toSqlParameterName,
																	 toSqlHasContentValues,
																	 toSqlStatic,
																	 fromSqlStatic,
																	 bothStatic,
																	 isAutoGeneratedPrimaryKey);
		}
	}
}
