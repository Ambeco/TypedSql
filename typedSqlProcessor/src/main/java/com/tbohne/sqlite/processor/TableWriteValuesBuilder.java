package com.tbohne.sqlite.processor;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ArrayTypeName;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.tbohne.sqlite.processor.models.CreateTableModel;
import com.tbohne.sqlite.processor.models.CreateTableNames;
import com.tbohne.sqlite.processor.models.JavaBinderModel;
import com.tbohne.sqlite.processor.models.TableColumnModel;
import com.tbohne.sqlite.processor.util.Output;
import com.tbohne.sqlite.processor.util.StringHelpers;

import org.checkerframework.checker.nullness.qual.Nullable;

import java.util.BitSet;
import java.util.Objects;

import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;

public class TableWriteValuesBuilder {
	private static final String CONTENT_VALUES_NAME = "values";
	private static final String BITSET_NAME = "fieldsSet";
	private static final String[] RAW_GETTER_SUFFIXES = {"AsLong", "AsDouble", "AsString", "AsByteArray"};
	private final ProcessingEnvironment environment;
	private final Elements elements;
	private final Types types;
	private final Output messager;
	private final TypeName stringName;
	private final TypeName blobName;
	private final TypeMirror rawBinderMirror;

	TableWriteValuesBuilder(ProcessingEnvironment environment, Output messager) {
		this.environment = environment;
		this.types = environment.getTypeUtils();
		this.elements = environment.getElementUtils();
		this.messager = messager;

		stringName = ClassName.get(String.class);
		blobName = ArrayTypeName.of(ClassName.BYTE);
		rawBinderMirror = elements.getTypeElement("com.tbohne.sqlite.binders.RawBinder").asType();
	}

	public void addWriteValuesClass(
			TypeSpec.Builder parentClassBuilder,
			TypeElement tableElement,
			CreateTableModel createTable,
			CreateTableNames names)
	{
		TypeName contentValuesTypeName = ClassName.get("android.content", "ContentValues");
		TypeSpec.Builder
				inserterBuilder =
				TypeSpec.classBuilder(names.writeValuesType).addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);
		int columnCount = createTable.javaColumnToBinderMap.size();
		inserterBuilder.addField(FieldSpec.builder(
				names.binderSetType,
				names.binderSetName,
				Modifier.PRIVATE,
				Modifier.FINAL).build());
		inserterBuilder.addField(FieldSpec.builder(BitSet.class, BITSET_NAME, Modifier.PRIVATE, Modifier.FINAL)
																			.initializer("new BitSet($L)", columnCount)
																			.build());
		inserterBuilder.addField(FieldSpec.builder(
				contentValuesTypeName,
				CONTENT_VALUES_NAME,
				Modifier.PRIVATE,
				Modifier.FINAL).initializer("new ContentValues()").build());
		inserterBuilder.addMethod(MethodSpec.constructorBuilder()
																				.addModifiers(Modifier.PUBLIC)
																				.addParameter(names.binderSetType, names.binderSetName)
																				.addStatement("this.$N = $N", names.binderSetName, names.binderSetName)
																				.build());
		for (int i = 0; i < createTable.javaColumns.size(); i++) {
			JavaBinderModel binder = createTable.javaColumns.get(i);
			if (binder.isAutoGeneratedPrimaryKey) {
				continue;
			}
			TypeName
					fieldType =
					TypeName.get(binder.toSqlJavaMirror).annotated(AnnotationSpec.builder(Nullable.class).build());
			inserterBuilder.addField(fieldType, binder.columnJavaName);
			addInserterSetter(inserterBuilder, tableElement, names, binder);
			addInserterGetter(inserterBuilder, tableElement, names, binder);
		}
		inserterBuilder.addMethod(MethodSpec.methodBuilder("getValues")
																				.returns(contentValuesTypeName)
																				.addStatement("return this.values")
																				.build());
		parentClassBuilder.addType(inserterBuilder.build());

		//Add inserter factory class
		TypeSpec.Builder
				factoryBuilder =
				TypeSpec.classBuilder(names.writeValuesFactoryType)
								.addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);
		factoryBuilder.addField(FieldSpec.builder(
				names.binderSetType,
				names.binderSetName,
				Modifier.PRIVATE,
				Modifier.FINAL).build());
		factoryBuilder.addMethod(MethodSpec.constructorBuilder()
																			 .addModifiers(Modifier.PUBLIC)
																			 .addAnnotation(ClassName.get("javax.inject", "Inject"))
																			 .addParameter(names.binderSetType, names.binderSetName)
																			 .addStatement("this.$N = $N", names.binderSetName, names.binderSetName)
																			 .build());
		factoryBuilder.addMethod(MethodSpec.methodBuilder("create")
																			 .returns(names.writeValuesType)
																			 .addModifiers(Modifier.PUBLIC)
																			 .addStatement(CodeBlock.builder()
																															.add("return new $T($N)",
																																	 names.writeValuesType,
																																	 names.binderSetName)
																															.build())
																			 .build());
		parentClassBuilder.addType(factoryBuilder.build());
	}

	private void addInserterSetter(
			TypeSpec.Builder classBuilder, TypeElement tableElement, CreateTableNames names, JavaBinderModel binder)
	{
		if (!types.isSameType(binder.binderMirror, rawBinderMirror)) {
			String binderSource = binder.toSqlStatic ? binder.binderMirror.toString() : ("binders." + binder.binderName);
			ParameterSpec
					parameter =
					ParameterSpec.builder(TypeName.get(binder.toSqlJavaMirror), binder.toSqlParameterName).build();
			MethodSpec.Builder
					method =
					MethodSpec.methodBuilder("set" + StringHelpers.sqlToJavaSuffix(binder.columnJavaName))
										.addModifiers(Modifier.PUBLIC)
										.addParameter(parameter)
										.returns(TypeName.VOID);
			if (binder.toSqlHasContentValues) {
				method.addStatement("$N.toSql($N, values)", binderSource, binder.toSqlParameterName);
			} else if (binder.columns.size() == 1 && binder.columns.get(0) != null) {
				TableColumnModel column = (TableColumnModel) Objects.requireNonNull(binder.columns.get(0));
				method.addStatement(
						"this.values.put(\"$N\", $N.toSql($N))",
						column.sqlName,
						binderSource,
						binder.toSqlParameterName);
			} else {
				method.addStatement("throw new %N(\"$N#toSql has incorrect parameter types\")",
														UnsupportedOperationException.class,
														binder.binderMirror);
			}
			classBuilder.addMethod(method.addStatement("this.$N = $N", binder.columnJavaName, binder.toSqlParameterName)
																	 .addStatement("this.$N.set($T.$N)",
																								 BITSET_NAME,
																								 names.javaColumnNumberType,
																								 binder.columnJavaName)
																	 .build());
		} else {
			if (binder.columns.size() != 1) {
				throw new IllegalStateException(binder.columnJavaName
																				+ " has multiple columns but is rawBinderMirror, which is incompatable");
			}
			TableColumnModel column = (TableColumnModel) Objects.requireNonNull(binder.columns.get(0));
			TypeName[] types = new TypeName[]{TypeName.LONG, TypeName.DOUBLE, stringName, blobName};
			for (int i = 0; i < types.length; i++) {
				if (binder.toSqlJavaMirror.getAnnotation(Nullable.class) != null) {
					types[i].annotations.add(AnnotationSpec.builder(Nullable.class).build());
				}
				classBuilder.addMethod(MethodSpec.methodBuilder("set" + StringHelpers.sqlToJavaSuffix(binder.columnJavaName))
																				 .addModifiers(Modifier.PUBLIC)
																				 .addParameter(types[i], binder.toSqlParameterName)
																				 .addStatement("values.put(\"$N\", $N)",
																											 column.sqlName,
																											 binder.toSqlParameterName)
																				 .addStatement("$N.set(%T.$N)",
																											 BITSET_NAME,
																											 names.javaColumnNumberType,
																											 binder.columnJavaName)
																				 .build());
			}
		}
	}

	private void addInserterGetter(
			TypeSpec.Builder classBuilder, TypeElement tableElement, CreateTableNames names, JavaBinderModel binder)
	{
		TypeName fieldNotSetException = ClassName.get("com.tbohne.sqlite.exceptions", "FieldNotSetException");
		if (!types.isSameType(binder.binderMirror, rawBinderMirror)) {
			MethodSpec.Builder
					method =
					MethodSpec.methodBuilder("get" + StringHelpers.sqlToJavaSuffix(binder.columnJavaName))
										.addModifiers(Modifier.PUBLIC)
										.returns(TypeName.get(binder.toSqlJavaMirror));
			method.addCode(CodeBlock.builder()
															.add("if (!$N.get($T.$N))\n",
																	 BITSET_NAME,
																	 names.javaColumnNumberType,
																	 binder.columnJavaName)
															.indent()
															.addStatement("throw new $T($S)", fieldNotSetException, binder.columnJavaName)
															.unindent()
															.addStatement("return $N", binder.columnJavaName)
															.build());
			classBuilder.addMethod(method.build());
		} else {
			if (binder.columns.size() != 1) {
				throw new IllegalStateException(binder.columnJavaName
																				+ " has multiple columns but is rawBinderMirror, which is incompatable");
			}
			TableColumnModel column = (TableColumnModel) Objects.requireNonNull(binder.columns.get(0));
			TypeName[] types = new TypeName[]{TypeName.LONG, TypeName.DOUBLE, stringName, blobName};
			for (int i = 0; i < types.length; i++) {
				if (binder.toSqlJavaMirror.getAnnotation(Nullable.class) != null) {
					types[i].annotations.add(AnnotationSpec.builder(Nullable.class).build());
				}
				MethodSpec.Builder
						method =
						MethodSpec.methodBuilder("get"
																		 + StringHelpers.sqlToJavaSuffix(binder.columnJavaName)
																		 + RAW_GETTER_SUFFIXES[i]).addModifiers(Modifier.PUBLIC);
				method.addCode(CodeBlock.builder()
																.add("if (!$N.get($T.$N))",
																		 BITSET_NAME,
																		 names.javaColumnNumberType,
																		 binder.columnJavaName)
																.indent()
																.addStatement("throw new $T($S)", fieldNotSetException, binder.columnJavaName)
																.unindent()
																.addStatement("$N.get$L(%T.$N)",
																							BITSET_NAME,
																							RAW_GETTER_SUFFIXES[i],
																							names.javaColumnNumberType,
																							binder.columnJavaName)
																.build());
				classBuilder.addMethod(method.build());
			}
		}
	}
}
