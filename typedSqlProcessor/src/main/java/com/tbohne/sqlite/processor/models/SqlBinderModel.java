package com.tbohne.sqlite.processor.models;

import com.google.common.collect.ImmutableList;
import com.tbohne.sqlite.annotations.createTable.ColumnBinder;
import com.tbohne.sqlite.annotations.createTable.TableColumn;
import com.tbohne.sqlite.annotations.enums.Affinity;
import com.tbohne.sqlite.annotations.query.ProjectionExpression;
import com.tbohne.sqlite.binders.AffinityBinder;
import com.tbohne.sqlite.binders.ByteArrayBinder;
import com.tbohne.sqlite.binders.ByteArrayNonNullBinder;
import com.tbohne.sqlite.binders.DoubleBinder;
import com.tbohne.sqlite.binders.DoubleNonNullBinder;
import com.tbohne.sqlite.binders.LongBinder;
import com.tbohne.sqlite.binders.LongNonNullBinder;
import com.tbohne.sqlite.binders.RawBinder;
import com.tbohne.sqlite.binders.StringBinder;
import com.tbohne.sqlite.binders.StringNonNullBinder;
import com.tbohne.sqlite.binders.VoidBinder;
import com.tbohne.sqlite.processor.util.Output;
import com.tbohne.sqlite.processor.util.ProcessorHelpers;

import org.checkerframework.checker.nullness.qual.Nullable;

import java.util.HashMap;

import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;

/**
 * {@link ColumnBinder}
 */
public class SqlBinderModel {
	public final DeclaredType binderMirror;
	public final @Nullable String tableJavaName;
	public final String javaName;
	public final int index;
	public final TypeMirror rawSqlParameterType;
	public final boolean isAutoGeneratedPrimaryKey;

	private SqlBinderModel(
			DeclaredType binderMirror,
			@Nullable String tableJavaName,
			String javaName,
			int index,
			TypeMirror rawSqlParameterType,
			boolean isAutoGeneratedPrimaryKey)
	{
		this.binderMirror = binderMirror;
		this.tableJavaName = tableJavaName;
		this.javaName = javaName;
		this.index = index;
		this.rawSqlParameterType = rawSqlParameterType;
		this.isAutoGeneratedPrimaryKey = isAutoGeneratedPrimaryKey;
	}

	public static SqlBinderModel buildImplicitPrimaryKey(
			ProcessingEnvironment environment, @Nullable String tableJavaName, String javaName)
	{
		DeclaredType
				binderMirror =
				(DeclaredType) environment.getElementUtils().getTypeElement(LongNonNullBinder.class.getName()).asType();
		TypeMirror typeMirror = environment.getElementUtils().getTypeElement(Long.class.getName()).asType();
		return new SqlBinderModel(binderMirror, tableJavaName, javaName, 0, typeMirror, true);
	}

	public static ImmutableList<SqlBinderModel> buildList(
			ProcessingEnvironment environment,
			@Nullable Output messager,
			TypeElement tableElement,
			@Nullable String tableJavaName,
			String javaColumnName,
			String sqlColumnName,
			TableColumn column,
			HashMap<String, SqlBinderModel> outputJavaToBinder)
	{
		return buildList(environment,
										 messager,
										 tableElement,
										 tableJavaName,
										 javaColumnName,
										 sqlColumnName,
										 new TableColumnAnnotation(column),
										 outputJavaToBinder);
	}

	public static ImmutableList<SqlBinderModel> buildList(
			ProcessingEnvironment environment,
			@Nullable Output messager,
			TypeElement tableElement,
			String tableJavaName,
			String javaColumnName,
			String sqlColumnName,
			ProjectionExpression expression,
			HashMap<String, SqlBinderModel> outputJavaToBinder)
	{
		return buildList(environment,
										 messager,
										 tableElement,
										 tableJavaName,
										 javaColumnName,
										 sqlColumnName,
										 new CursorExpressionAnnotation(expression),
										 outputJavaToBinder);
	}

	public static ImmutableList<SqlBinderModel> buildList(
			ProcessingEnvironment environment,
			@Nullable Output messager,
			TypeElement tableElement,
			String tableJavaName,
			String javaColumnName,
			String sqlColumnName,
			ColumnAnnotation column,
			HashMap<String, SqlBinderModel> outputJavaToBinder)
	{
		DeclaredType
				voidBinderMirror =
				(DeclaredType) environment.getElementUtils().getTypeElement(VoidBinder.class.getName()).asType();
		DeclaredType
				useStorageBinderMirror =
				(DeclaredType) environment.getElementUtils().getTypeElement(AffinityBinder.class.getName()).asType();
		DeclaredType
				rawBinderMirror =
				(DeclaredType) environment.getElementUtils().getTypeElement(RawBinder.class.getName()).asType();
		DeclaredType parameterNoGenericsBinderMirror = column.binderWithoutGenerics();
		DeclaredType
				parameterBinderMirror =
				environment.getTypeUtils()
									 .getDeclaredType(
											 (TypeElement) parameterNoGenericsBinderMirror.asElement(),
											 column.binderGenerics().toArray(new TypeMirror[0]));
		//TODO does parameterBinderMirror have the actual type arguments set properly?
		String binderString = getStorageBinderString(environment, column.affinity(), column.notNull());
		DeclaredType
				actualStorageMirror =
				(DeclaredType) environment.getElementUtils().getTypeElement(binderString).asType();
		ImmutableList.Builder<SqlBinderModel> list = ImmutableList.builder();
		if (environment.getTypeUtils().isSameType(useStorageBinderMirror, parameterBinderMirror)) {
			SqlBinderModel
					binder =
					new SqlBinderModel(actualStorageMirror, tableJavaName, javaColumnName, 0, actualStorageMirror, false);
			list.add(binder);
			outputJavaToBinder.put(javaColumnName, binder);
		} else if (!environment.getTypeUtils().isSameType(voidBinderMirror, parameterBinderMirror)) {
			SqlBinderModel
					binder =
					new SqlBinderModel(parameterBinderMirror, tableJavaName, javaColumnName, 0, actualStorageMirror, false);
			list.add(binder);
			outputJavaToBinder.put(javaColumnName, binder);
		}
		return list.build();
	}

	public static String getStorageBinderString(ProcessingEnvironment environment, Affinity affinity, boolean nonNull) {
		switch (affinity) {
			case INTEGER:
				return nonNull ? LongNonNullBinder.class.getName() : LongBinder.class.getName();
			case REAL:
				return nonNull ? DoubleNonNullBinder.class.getName() : DoubleBinder.class.getName();
			case TEXT:
				return nonNull ? StringNonNullBinder.class.getName() : StringBinder.class.getName();
			case BLOB:
				return nonNull ? ByteArrayNonNullBinder.class.getName() : ByteArrayBinder.class.getName();
			default:
				throw new IllegalStateException("Unknown storage class " + affinity);
		}
	}

	public interface ColumnAnnotation {
		DeclaredType binderWithoutGenerics();

		ImmutableList<? extends DeclaredType> binderGenerics();

		Affinity affinity();

		boolean notNull();
	}

	public static final class TableColumnAnnotation
			implements ColumnAnnotation
	{
		private final TableColumn column;

		public TableColumnAnnotation(TableColumn column) {
			this.column = column;
		}

		public DeclaredType binderWithoutGenerics() {
			return ProcessorHelpers.getTypeMirror(() -> column.binder().value());
		}

		public ImmutableList<? extends DeclaredType> binderGenerics() {
			return ProcessorHelpers.getTypeMirrors(() -> column.binder().binderGenerics());
		}

		public Affinity affinity() {
			return column.affinity();
		}

		public boolean notNull() {
			return column.notNull().value();
		}
	}

	public static final class CursorExpressionAnnotation
			implements ColumnAnnotation
	{
		private final ProjectionExpression expression;

		public CursorExpressionAnnotation(ProjectionExpression expression) {
			this.expression = expression;
		}

		public DeclaredType binderWithoutGenerics() {
			return ProcessorHelpers.getTypeMirror(expression::binder);
		}

		public ImmutableList<? extends DeclaredType> binderGenerics() {
			return ProcessorHelpers.getTypeMirrors(expression::binderGenerics);
		}

		public Affinity affinity() {
			return expression.affinity();
		}

		public boolean notNull() {
			return expression.notNull();
		}
	}
}
