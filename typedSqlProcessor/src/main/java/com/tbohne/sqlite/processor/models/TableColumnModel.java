package com.tbohne.sqlite.processor.models;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.tbohne.sqlite.annotations.CreateTable;
import com.tbohne.sqlite.annotations.createTable.TableColumn;
import com.tbohne.sqlite.annotations.enums.Affinity;
import com.tbohne.sqlite.processor.util.Output;
import com.tbohne.sqlite.processor.util.StringHelpers;

import org.checkerframework.checker.nullness.qual.Nullable;

import java.util.HashMap;

import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.TypeElement;

/**
 * {@link com.tbohne.sqlite.annotations.createTable.TableColumn}
 */
public class TableColumnModel
		extends AbstractColumnModel
{
	public final @Nullable ColumnPrimaryKeyModel primaryKey;
	public final @Nullable NotNullModel notNull;
	public final @Nullable ColumnUniqueModel unique;
	public final ImmutableList<ColumnCheckModel> checks;
	public final @Nullable DefaultValueModel defaultValue;
	public final @Nullable ColumnCollationModel collation;
	public final @Nullable ForeignKeyModel foreignKey;

	private TableColumnModel(
			String javaName,
			String sqlName,
			String tableJavaName,
			Affinity affinity,
			@Nullable ColumnPrimaryKeyModel primaryKey,
			@Nullable NotNullModel notNull,
			@Nullable ColumnUniqueModel unique,
			ImmutableList<ColumnCheckModel> checks,
			@Nullable DefaultValueModel defaultValue,
			@Nullable ColumnCollationModel collation,
			@Nullable ForeignKeyModel foreignKey,
			ImmutableList<SqlBinderModel> binders,
			ImmutableMap<String, SqlBinderModel> javaToBinderMap,
			boolean isAutoGeneratedPrimaryKey)
	{
		super(javaName,
					sqlName,
					tableJavaName,
					affinity,
					notNull != null,
					unique != null,
					isAutoGeneratedPrimaryKey,
					binders,
					javaToBinderMap);
		this.primaryKey = primaryKey;
		this.notNull = notNull;
		this.unique = unique;
		this.checks = checks;
		this.defaultValue = defaultValue;
		this.collation = collation;
		this.foreignKey = foreignKey;
	}

	public static ImmutableList<TableColumnModel> buildList(
			ProcessingEnvironment environment,
			@Nullable Output messager,
			TypeElement tableElement,
			String tableSqlName,
			String tableJavaName,
			CreateTable createTable,
			HashMap<String, TableColumnModel> sqlNameColumnMap,
			HashMap<String, CreateTableModel> pathToTableCache)
	{
		TableColumn[] columns = createTable.columns();
		if (messager != null && columns.length == 0) {
			messager.error(tableElement, "SqliteTable must have at least one column");
		}
		ImmutableList.Builder<TableColumnModel> list = ImmutableList.builder();
		boolean hasPrimaryKey = createTable.withoutRowId() || createTable.primaryKey().value().length > 0;
		for (int i = 0; i < columns.length; i++) {
			TableColumnModel model = build(environment,
																		 messager,
																		 tableElement,
																		 tableSqlName,
																		 tableJavaName,
																		 i,
																		 columns[i],
																		 sqlNameColumnMap,
																		 pathToTableCache);
			list.add(model);
			if (model.primaryKey != null) {
				hasPrimaryKey = true;
			}
		}
		if (!hasPrimaryKey) {
			String name = calculateAutomaticRowIdName(columns);
			SqlBinderModel binder = SqlBinderModel.buildImplicitPrimaryKey(environment, tableJavaName, name);
			list.add(new TableColumnModel(name,
																		name,
																		tableJavaName,
																		Affinity.INTEGER,
																		ColumnPrimaryKeyModel.buildForImplicitPrimaryKey(),
																		NotNullModel.buildForImplicitPrimaryKey(),
																		ColumnUniqueModel.buildForImplicitPrimaryKey(),
																		null,
																		null,
																		null,
																		null,
																		ImmutableList.of(binder),
																		ImmutableMap.of(name, binder),
																		true));
		}
		return list.build();
	}

	static String calculateAutomaticRowIdName(TableColumn[] columns) {
		if (!hasColumnWithName(columns, "rowid")) {
			return "rowid";
		}
		if (!hasColumnWithName(columns, "oid")) {
			return "oid";
		}
		return "_rowid_";
	}

	static boolean hasColumnWithName(TableColumn[] columns, String name) {
		for (int i = 0; i < columns.length; i++) {
			TableColumn column = columns[i];
			if (column.sqlName().equals(name)) {
				return true;
			}
			if (!column.sqlName().isEmpty()) {
				continue;
			}
			if (column.name().equals(name)) {
				return true;
			}
		}
		return false;
	}

	static String getJavaName(
			ProcessingEnvironment environment,
			@Nullable Output messager,
			TypeElement tableElement,
			int index,
			TableColumn column)
	{
		if (!column.name().isEmpty()) {
			return column.name();
		} else if (!column.sqlName().isEmpty()) {
			return StringHelpers.sqlToJava(column.sqlName());
		} else {
			if (messager != null) {
				messager.error(tableElement, "Column #%d must have a name", index);
			}
			return "column" + index;
		}
	}

	static String getSqlName(
			ProcessingEnvironment environment,
			@Nullable Output messager,
			TypeElement tableElement,
			int index,
			TableColumn column)
	{
		if (!column.sqlName().isEmpty()) {
			return column.sqlName();
		} else if (!column.name().isEmpty()) {
			return StringHelpers.javaToSql(column.name());
		} else {
			if (messager != null) {
				messager.error(tableElement, "Column #%d must have a name", index);
			}
			return "column" + index;
		}
	}

	public static TableColumnModel build(
			ProcessingEnvironment environment,
			@Nullable Output messager,
			TypeElement tableElement,
			String tableSqlName,
			String tableJavaName,
			int index,
			TableColumn column,
			HashMap<String, TableColumnModel> sqlNameColumnMap,
			HashMap<String, CreateTableModel> pathToTableCache)
	{
		String javaName = getJavaName(environment, messager, tableElement, index, column);
		if (messager != null && !StringHelpers.validJavaId(javaName)) {
			messager.error(tableElement, "Column #%d has invalid java name \"%s\"", index, javaName);
		}
		String sqlName = getSqlName(environment, messager, tableElement, index, column);
		if (messager != null && !StringHelpers.validSqlId(sqlName)) {
			messager.error(tableElement, "Column #%d has invalid sql name \"%s\"", index, sqlName);
		}
		ColumnPrimaryKeyModel
				primaryKey =
				ColumnPrimaryKeyModel.build(environment, messager, tableElement, sqlName, column);
		ColumnUniqueModel unique = ColumnUniqueModel.build(environment, messager, tableElement, sqlName, column);
		if (messager != null && primaryKey != null && unique != null) {
			messager.error(tableElement,
										 "Column %s unique constraint %s is redundant: column is already primary key",
										 sqlName,
										 unique.constraintName);
		}
		HashMap<String, SqlBinderModel> binderMap = new HashMap<>();
		return new TableColumnModel(javaName,
																sqlName,
																tableJavaName,
																column.affinity(),
																primaryKey,
																NotNullModel.build(environment, messager, tableElement, sqlName, column.notNull()),
																unique,
																ColumnCheckModel.buildList(environment, messager, tableElement, sqlName, column),
																DefaultValueModel.build(environment, messager, tableElement, sqlName, column),
																ColumnCollationModel.build(environment, messager, tableElement, sqlName, column),
																ForeignKeyModel.buildForColumn(environment,
																															 messager,
																															 tableElement,
																															 sqlName,
																															 column,
																															 sqlNameColumnMap,
																															 pathToTableCache),
																SqlBinderModel.buildList(environment,
																												 messager,
																												 tableElement,
																												 tableJavaName,
																												 javaName,
																												 sqlName,
																												 column,
																												 binderMap),
																ImmutableMap.copyOf(binderMap),
																false);
	}

}
