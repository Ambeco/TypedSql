package com.tbohne.sqlite.processor.models;


import com.google.common.base.Strings;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.tbohne.sqlite.annotations.CreateIndex;
import com.tbohne.sqlite.annotations.CreateProjection;
import com.tbohne.sqlite.annotations.CreateTable;
import com.tbohne.sqlite.annotations.CreateView;
import com.tbohne.sqlite.annotations.enums.Affinity;
import com.tbohne.sqlite.annotations.query.ProjectionTable;
import com.tbohne.sqlite.processor.util.ImmutableMethods;
import com.tbohne.sqlite.processor.util.Output;
import com.tbohne.sqlite.processor.util.ProcessorHelpers;
import com.tbohne.sqlite.processor.util.StringHelpers;

import org.checkerframework.checker.nullness.qual.Nullable;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;

import sun.reflect.generics.reflectiveObjects.NotImplementedException;

/**
 * {@link ProjectionTable}
 */
public class ProjectionTableColumnModel
		extends AbstractColumnModel
{

	public final String tableSqlName;
	public final @Nullable String tableAlias;
	public final DeclaredType tableViewIndex;
	public final @Nullable CreateTableModel table;
	//public final @Nullable CreateViewModel view;
	public final @Nullable CreateIndexModel index;
	public final @Nullable TableColumnModel column;

	private ProjectionTableColumnModel(
			String javaName,
			String sqlName,
			String tableJavaName,
			Affinity affinity,
			boolean isNonNull,
			boolean unique,
			boolean isAutoGeneratedPrimaryKey,
			ImmutableList<SqlBinderModel> sqlBinder,
			ImmutableMap<String, SqlBinderModel> javaToBinderMap,
			String tableSqlName,
			@Nullable String tableAlias,
			DeclaredType tableViewIndex,
			@Nullable CreateTableModel table,
			//@Nullable CreateViewModel view,
			@Nullable CreateIndexModel index,
			@Nullable TableColumnModel column)
	{
		super(javaName,
					sqlName,
					tableJavaName,
					affinity,
					isNonNull,
					unique,
					isAutoGeneratedPrimaryKey,
					sqlBinder,
					javaToBinderMap);
		this.tableSqlName = tableSqlName;
		this.tableAlias = tableAlias;
		this.tableViewIndex = tableViewIndex;
		this.table = table;
		//this.view = view;
		this.index = index;
		this.column = column;
	}

	public static ImmutableList<ProjectionTableColumnModel> build(
			ProcessingEnvironment environment,
			Output messager,
			TypeElement projectionElement,
			CreateProjection createProjection,
			int tableIndex,
			ProjectionTable projectionTable,
			HashMap<String, CreateTableModel> pathToTableCache)
	{
		if (messager != null && !StringHelpers.validOrEmptySqlId(projectionTable.tableAlias())) {
			messager.error(
					projectionElement,
					"Projection table #%d name \"%s\" is invalid",
					tableIndex,
					projectionTable.tableAlias());
		}
		DeclaredType tableViewMirror = (DeclaredType) ProcessorHelpers.getTypeMirror(projectionTable::value);
		Element tableViewElement = tableViewMirror.asElement();
		CreateTable remoteTable = tableViewElement.getAnnotation(CreateTable.class);
		if (remoteTable != null) {
			return buildTableList(environment,
														messager,
														projectionElement,
														createProjection,
														tableIndex,
														projectionTable,
														tableViewMirror,
														remoteTable,
														pathToTableCache);
		}
		CreateView remoteView = tableViewElement.getAnnotation(CreateView.class);
		if (remoteView != null) {
			return buildViewList(environment,
													 messager,
													 projectionElement,
													 createProjection,
													 tableIndex,
													 projectionTable,
													 tableViewMirror,
													 remoteView,
													 pathToTableCache);
		}
		CreateIndex remoteIndex = tableViewElement.getAnnotation(CreateIndex.class);
		if (remoteIndex != null) {
			return buildIndexList(environment,
														messager,
														projectionElement,
														createProjection,
														tableIndex,
														projectionTable,
														tableViewMirror,
														remoteIndex,
														pathToTableCache);
		}
		if (messager != null) {
			messager.error(projectionElement,
										 "Projection table #%d %s references remote table %s which does not appear to have the @CreateTable, @CreateView, or @CreateIndex annotation",
										 tableIndex,
										 createProjection.projectionName(),
										 tableViewMirror);
		}
		return ImmutableList.of();
	}

	private static ImmutableList<ProjectionTableColumnModel> buildTableList(
			ProcessingEnvironment environment,
			Output messager,
			TypeElement projectionElement,
			CreateProjection createProjection,
			int tableIndex,
			ProjectionTable projectionTable,
			DeclaredType remoteTableMirror,
			CreateTable remoteTable,
			HashMap<String, CreateTableModel> pathToTableCache)
	{
		TypeElement remoteElement = ((TypeElement) remoteTableMirror.asElement());
		//TODO has to be lazy :(
		CreateTableModel cachedRemoteTableModel = pathToTableCache.get(remoteElement.getQualifiedName().toString());
		CreateTableModel remoteTableModel;
		if (cachedRemoteTableModel != null) {
			remoteTableModel = cachedRemoteTableModel;
		} else {
			remoteTableModel = CreateTableModel.build(environment, messager, remoteElement, remoteTable, pathToTableCache);
			pathToTableCache.put(remoteElement.getQualifiedName().toString(), remoteTableModel);
		}
		List<@Nullable TableColumnModel> columns;
		if (projectionTable.columns().length > 0) {
			columns = new ArrayList<>(projectionTable.columns().length);
			for (int j = 0; j < projectionTable.columns().length; j++) {
				String columnName = projectionTable.columns()[j];
				TableColumnModel columnModel = remoteTableModel.columnSqlMap.get(columnName);
				columns.add(columnModel);
				if (messager != null && columnModel == null) {
					messager.error(projectionElement,
												 "Projection table #%d %s references remote table %s which does not appear to have a %s column",
												 tableIndex,
												 createProjection.projectionName(),
												 remoteElement,
												 columnName);
				}
			}
		} else {
			columns = remoteTableModel.columnList;
		}
		ImmutableList.Builder<ProjectionTableColumnModel> results = ImmutableList.builder();
		for (int j = 0; j < columns.size(); j++) {
			TableColumnModel columnModel = columns.get(j);
			if (columnModel == null) {
				results.add(new ProjectionTableColumnModel(projectionTable.columns()[j],
																									 projectionTable.columns()[j],
																									 remoteTableModel.javaName,
																									 Affinity.INTEGER,
																									 false,
																									 false,
																									 false,
																									 ImmutableList.of(),
																									 ImmutableMap.of(),
																									 remoteTableModel.sqlName,
																									 Strings.emptyToNull(projectionTable.tableAlias()),
																									 remoteTableMirror,
																									 remoteTableModel,
																									 //null,
																									 null,
																									 columnModel));
			} else {
				results.add(new ProjectionTableColumnModel(columnModel.javaName,
																									 columnModel.sqlName,
																									 columnModel.tableJavaName,
																									 columnModel.affinity,
																									 columnModel.notNull != null,
																									 columnModel.unique != null,
																									 columnModel.isAutoGeneratedPrimaryKey,
																									 columnModel.sqlBinders,
																									 columnModel.javaToBinderMap,
																									 remoteTableModel.sqlName,
																									 Strings.emptyToNull(projectionTable.tableAlias()),
																									 remoteTableMirror,
																									 remoteTableModel,
																									 //null,
																									 null,
																									 columnModel));
			}
		}
		return results.build();
	}

	private static ImmutableList<ProjectionTableColumnModel> buildIndexList(
			ProcessingEnvironment environment,
			Output messager,
			TypeElement projectionElement,
			CreateProjection createProjection,
			int tableIndex,
			ProjectionTable projectionTable,
			DeclaredType remoteIndexMirror,
			CreateIndex remoteIndex,
			HashMap<String, CreateTableModel> pathToTableCache)
	{
		TypeMirror remoteTableMirror = remoteIndexMirror.getEnclosingType();
		if (remoteTableMirror == null) {
			messager.error(projectionElement,
										 "Projection table #%d %s references remote index %s which is not a member of a @CreateTable",
										 tableIndex,
										 createProjection.projectionName(),
										 remoteIndexMirror);
			return null;
		}
		CreateTable remoteTable = remoteTableMirror.getAnnotation(CreateTable.class);
		if (remoteTable == null) {
			messager.error(projectionElement,
										 "Projection table #%d %s references remote index %s which is a member of %s, which does not appear to be a @CreateTable",
										 tableIndex,
										 createProjection.projectionName(),
										 remoteIndexMirror);
			return null;
		}
		TypeElement remoteTableElement = (TypeElement) ((DeclaredType) remoteTable).asElement();
		CreateTableModel cachedRemoteTableModel = pathToTableCache.get(remoteTableElement.getQualifiedName().toString());
		CreateTableModel remoteTableModel;
		if (cachedRemoteTableModel != null) {
			remoteTableModel = cachedRemoteTableModel;
		} else {
			remoteTableModel =
					CreateTableModel.build(environment, messager, remoteTableElement, remoteTable, pathToTableCache);
			pathToTableCache.put(remoteTableElement.getQualifiedName().toString(), remoteTableModel);
		}
		CreateIndexModel remoteIndexModel = remoteTableModel.sqlIndexMap.get(remoteIndex.sqlName());
		if (remoteIndexModel == null) {
			throw new IllegalStateException("Somehow index "
																			+ remoteIndex.sqlName()
																			+ " isn't a member of table "
																			+ remoteTableElement);
		}
		List<@Nullable TableColumnModel> columns;
		if (projectionTable.columns().length > 0) {
			columns = new ArrayList<>(projectionTable.columns().length);
			for (int j = 0; j < projectionTable.columns().length; j++) {
				String columnName = projectionTable.columns()[j];
				TableColumnModel columnModel = remoteTableModel.columnSqlMap.get(columnName);
				columns.add(columnModel);
				if (messager != null && columnModel == null) {
					messager.error(projectionElement,
												 "Projection table #%d %s references remote index %s which does not appear to have a %s column",
												 tableIndex,
												 createProjection.projectionName(),
												 remoteIndexMirror,
												 columnName);
				}
			}
		} else {
			columns = ImmutableMethods.listTransform(remoteIndexModel.columns, indexed -> indexed.column.get());
		}
		ImmutableList.Builder<ProjectionTableColumnModel> results = ImmutableList.builder();
		for (int j = 0; j < columns.size(); j++) {
			String columnName = projectionTable.columns()[j];
			TableColumnModel columnModel = remoteTableModel.columnSqlMap.get(columnName);
			if (columnModel == null) {
				if (messager != null) {
					messager.error(projectionElement,
												 "Projection table #%d %s references remote table %s which does not appear to have a %s column",
												 tableIndex,
												 createProjection.projectionName(),
												 remoteTableMirror,
												 columnName);
				}
				results.add(new ProjectionTableColumnModel(columnName,
																									 columnName,
																									 remoteTableModel.javaName,
																									 Affinity.INTEGER,
																									 false,
																									 false,
																									 false,
																									 ImmutableList.of(),
																									 ImmutableMap.of(),
																									 remoteTableModel.sqlName,
																									 Strings.emptyToNull(projectionTable.tableAlias()),
																									 (DeclaredType) remoteTableMirror,
																									 remoteTableModel,
																									 //null,
																									 null,
																									 columnModel));
			} else {
				results.add(new ProjectionTableColumnModel(columnModel.javaName,
																									 columnModel.sqlName,
																									 columnModel.tableJavaName,
																									 columnModel.affinity,
																									 columnModel.notNull != null,
																									 columnModel.unique != null,
																									 columnModel.isAutoGeneratedPrimaryKey,
																									 columnModel.sqlBinders,
																									 columnModel.javaToBinderMap,
																									 remoteTableModel.sqlName,
																									 Strings.emptyToNull(projectionTable.tableAlias()),
																									 (DeclaredType) remoteTableMirror,
																									 remoteTableModel,
																									 //null,
																									 null,
																									 columnModel));
			}
		}
		return results.build();
	}

	private static ImmutableList<ProjectionTableColumnModel> buildViewList(
			ProcessingEnvironment environment,
			Output messager,
			TypeElement projectionElement,
			CreateProjection createProjection,
			int i,
			ProjectionTable projectionTable,
			DeclaredType remoteViewMirror,
			CreateView remoteView,
			HashMap<String, CreateTableModel> pathToTableCache)
	{
		//TODO: implement
		throw new NotImplementedException();
	}
}

