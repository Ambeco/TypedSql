package com.tbohne.sqlite.processor.models;


import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.tbohne.sqlite.annotations.CreateProjection;
import com.tbohne.sqlite.annotations.enums.Affinity;
import com.tbohne.sqlite.annotations.query.ProjectionExpression;
import com.tbohne.sqlite.processor.util.Output;
import com.tbohne.sqlite.processor.util.StringHelpers;

import org.checkerframework.checker.nullness.qual.Nullable;

import java.util.HashMap;

import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.TypeElement;

/**
 * {@link ProjectionExpression}
 */
public class ProjectionExpressionModel
		extends AbstractColumnModel
{
	private ProjectionExpressionModel(
			String javaName,
			String sqlName,
			@Nullable String tableJavaName,
			Affinity affinity,
			boolean isNonNull,
			boolean isUnique,
			boolean isAutoGeneratedPrimaryKey,
			ImmutableList<SqlBinderModel> sqlBinder,
			ImmutableMap<String, SqlBinderModel> javaToBinderMap)
	{
		super(javaName,
					sqlName,
					tableJavaName,
					affinity,
					isNonNull,
					isUnique,
					isAutoGeneratedPrimaryKey,
					sqlBinder,
					javaToBinderMap);
	}

	public static ImmutableList<ProjectionExpressionModel> buildList(
			ProcessingEnvironment environment,
			@Nullable Output messager,
			TypeElement projectionElement,
			CreateProjection createProjection)
	{
		ProjectionExpression[] expressions = createProjection.expressions();
		ImmutableList.Builder<ProjectionExpressionModel> list = ImmutableList.builder();
		for (int i = 0; i < expressions.length; i++) {
			ProjectionExpression expression = expressions[i];
			list.add(build(environment, messager, projectionElement, i, expression));
		}
		return list.build();
	}

	public static ProjectionExpressionModel build(
			ProcessingEnvironment environment,
			Output messager,
			TypeElement projectionElement,
			int index,
			ProjectionExpression projectionExpression)
	{
		String javaName = getJavaName(messager, projectionElement, projectionExpression, index);
		String sqlName = getSqlName(messager, projectionElement, projectionExpression, javaName);
		HashMap<String, SqlBinderModel> binderMap = new HashMap<>();
		ImmutableList<SqlBinderModel>
				sqlBinders =
				SqlBinderModel.buildList(environment,
																 messager,
																 projectionElement,
																 null,
																 javaName,
																 sqlName,
																 projectionExpression,
																 binderMap);
		return new ProjectionExpressionModel(javaName,
																				 sqlName,
																				 null,
																				 projectionExpression.affinity(),
																				 projectionExpression.notNull(),
																				 projectionExpression.unique(),
																				 false,
																				 sqlBinders,
																				 ImmutableMap.copyOf(binderMap));
	}

	static String getJavaName(
			@Nullable Output messager, TypeElement projectionElement, ProjectionExpression projectionExpression, int index)
	{
		if (projectionExpression.name().isEmpty()) {
			if (messager != null && !StringHelpers.validJavaId(projectionExpression.name())) {
				messager.error(projectionElement, "Projection expression #%d name is empty", index);
			}
			return "expression" + index;
		}
		if (messager != null && !StringHelpers.validJavaId(projectionExpression.name())) {
			messager.error(
					projectionElement,
					"Projection expression #%d name \"%s\" is invalid",
					index,
					projectionExpression.name());
		}
		return projectionExpression.name();
	}

	static String getSqlName(
			@Nullable Output messager,
			TypeElement projectionElement,
			ProjectionExpression projectionExpression,
			String javaName)
	{
		String sqlName;
		if (projectionExpression.sqlName().isEmpty()) {
			sqlName = StringHelpers.javaToSql(javaName);
		} else {
			sqlName = projectionExpression.sqlName();
		}
		if (messager != null && !StringHelpers.validSqlId(sqlName)) {
			messager.error(projectionElement, "Projection expression has invalid sql name \"%s\"", sqlName);
		}
		return sqlName;
	}
}

